1  哈希表

1.1 HashTable vs HashMap

第一，继承不同

public class Hashtable extends Dictionary<> implements Map<>
public class HashMap  extends AbstractMap<> implements Map<>

第二，Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换

第三，Hashtable中，key和value都不允许出现null值。
在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

第四，两个遍历方式的内部实现上不同。

Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

第五

哈希值的使用不同，HashTable直接使用对象的hashCode，如下：

 　　int hash = key.hashCode();
     int index = (hash & 0x7FFFFFFF) % tab.length;

而HashMap重新计算hash值，而且用与代替求模：
int hash = hash(k);
int i = indexFor(hash, table.length);
 
static int hash(Object x) {
　　 int h = x.hashCode();
　　 h += ~(h << 9);
　　 h ^= (h >>> 14);
　　 h += (h << 4);
　　 h ^= (h >>> 10);
　　 return h;
}
static int indexFor(int h, int length) {
　　 return h & (length-1);
}

第六，Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

1.2 HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。

2 二叉树

2.1 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。

二叉搜索树，是指一棵空树或者具有下列性质的二叉树：

若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；

若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；

任意节点的左，右子树也分别为二叉搜索树；

没有键值相等的节点。

2.2 遍历

前序遍历
规则：若二叉树为空，则空操作返回，否则先访问根节点，再前序遍历左子树，再后序遍历右子树.

中序遍历
规则：若二叉树为空，则空操作返回，否则先从根节点开始（注意不是先访问根节点），再中序遍历左子树，然后是访问根节点，再中序遍历右子树.

后序遍历
规则：若二叉树为空，则空操作返回，否则先从根节点开始（注意不是先访问根节点），再中序遍历左子树，再中序遍历右子树，然后是访问根节点.

存在的问题
二叉搜索树插入时是按照一定规则进行插入的，因此在中序遍历时获得的数据是有序的，因此插入或者查找的效率还是比较高的．但是存在的一个问题是，如果插入的数据是单调变化的，那就变成了线性链表，最后导致查找效率降低．

3. 堆

堆（英语：heap)：堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：

1.堆中某个节点的值总是不大于或不小于其父节点的值；

2.堆总是一棵完全二叉树。

堆是一颗完全二叉树，在这棵树中，所有父节点都满足大于等于其子节点的堆叫大根堆，所有父节点都满足小于等于其子节点的堆叫小根堆。

常见的堆有二叉堆、斐波那契堆等。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。

为将一个元素 X 插入到堆中，我们在下一个可用位置创建一个空穴，否则该堆将不是完全数。如果 X 可以放在该空穴中而不破坏堆的序，那么插入完成。否则，我们把空穴的父节点上的元素。移入该空穴中，这样，空穴就朝着根的方向上冒一步。继续改过程直到 X 能被放入空穴中为止。这种实现过程称之为上滤：新元素在堆中上滤直到找出正确的插入位置。

当删除一个最小元时，要在根节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素 X 必须移动到该堆的某个地方。如果 X 可以直接被放到空穴中，那么 deleteMin 完成。不过这一般不太可能，因此我们将空穴的两个儿子中比较小者移入空穴，这样就把空穴向下推了一层。重复该步骤直到 X 可以被放入空穴中。因此，我们的做法是将 X 置入沿着从根开始包含最小儿子的一条路径上的一个正确的位置。

4. 图
无向图：图是有一组顶点和一组能够将两个顶点相连的边组成的
有向图：由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点
无向有权图：
有向有权图：

邻接矩阵表示法：如果结点a与结点b之间相连接，则A(a,b) = A(b,a) = 1，否则为0。

邻接表表示法：在邻接表表示法中，第一列代表的为结点，如0,1,2……，而后面的则代表为结点与其他结点相连接的结点
