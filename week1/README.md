1  数组，链表，跳表

1.1 数据结构

数组(Array)：因为数组在内存中的一段连续的地址存储，可以通过下标查找数组元素，所以查询的时间复杂度是O(1),但是添加和删除需要移动数组元素，所以时间复杂度是O(n) 

链表(LinkList)：因为加入了指针，可以通过改变指针的指向，所以添加和删除的时间复杂度是O(1),但是由于不知道元素的具体位置，所以查询的时间复杂度是O(n) 

跳表(SkipList)：为了解决链表查询时间复杂度高的问题，通过升维增加链表的方式，从而将查询时间复杂度降为O(logN)，这也是一种通过空间换时间的做法。Redis就是适用跳表来实现数据搜索的

1.2. 适用的算法 

双指针法：通过头尾指针，或者夹逼法，减低时间复杂度，比如从O(N平方）降到O(N)。这种算法可以用于解决移动零，两（三）个数之和，容器盛水移动零，两（三）个数之和，容器盛水等问题

动态规划法：斐波拉契数列，比如爬楼梯的问题，通过寻找最近重复的事件，推导出爬楼梯问题本质上是斐波拉契数列问题。

2 栈，队列，双端队列, 优先级队列


2.1 数据结构

栈(Stack): 先进后出

队列(Queue)：先进先出。Add/Remove方法会抛出异常，Offer/Pull也是添加或删除元素，区别是不会抛异常

源码分析：

双端队列(Deque)：两端都可以进出。Java 10新增加了addFirst, addLast, removeFirst, removeLast的方法，可以用于替代旧的push和pop方法

优先级队列（PriorityQueue）：通过给队列设置优先级规则，按照优先级取出数据。插入的时间复杂度是O(1), 取出的时间复杂度增加了为O(log(n))

源码分析

2.2 算法
符合从内到外或者从外到内，类似剥洋葱的模式的场景，适用于栈的数据结构

解题落脚点：

1. 条件判断

2. 循环

3. 回溯

思考：

1. 以时间换空间

2. 升维度

